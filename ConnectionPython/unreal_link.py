# -*- coding: utf-8 -*-
"""AgentesFinal.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K2tiOoyHZVjPEnc96k1EoXOR_AsjrsgD
"""

# en blueprint de Unreal

import agentpy as ap
from owlready2 import *
#import matplotlib.pyplot as plt
import math
#mport IPython

class Pos:
    def __init__(self, x, y):
        self.x = x
        self.y = y

LOAD_POS = Pos(23132.197348, -9420.391529)
#22193.554179594223 -9618.894075636932
# class truck:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y

#     def __str__(self):
#         return f"({self.x}, {self.y})"

# def READ_SPEED_FUNCTION():
#     speed = 1000
#     return speed

# def see(pos_x, pos_y):
#     truck_agent = truck(pos_x, pos_y)
#     args = {0:truck_agent}
#     return args

# def move():
#     return

# def main(pos_x, pos_y):
#     args = see(pos_x, pos_y)
#     print(args)
#     move()
#     return

"""Aquí copiamos lo que tenemos de la Evidencia 1 para adaptarlo vvv"""

onto = get_ontology("file:///content/ontologia_prueba.owl")

with onto:
  class Entidad(Thing):
        pass

  class Materiales(Entidad):
        pass

  class Truck(Entidad):
        pass

  class GoodTruck(Truck):
        pass

  class BadTruck(Truck):
        pass

  class Camera(Entidad):
        pass

  class PosX(DataProperty,FunctionalProperty):
        domain = [Entidad]
        range = [int]
  class PosY(DataProperty, FunctionalProperty):
        domain = [Entidad]
        range = [int]
  class Material(ObjectProperty, FunctionalProperty):
        domain = [Truck]
        range = [Materiales]

# speed = 0

class TruckAgent(ap.Agent):

    def setup(self):
        # self.agentID = 0 # No necesario porque eso se usa para colorear la animación de agentPy
        self.thisTruck = Truck()
        self.thisTruck.posX = self.model.p.truckPosX # Variable de Unreal
        self.thisTruck.posY = self.model.p.truckPosY # Variable de Unreal
        self.thisTruck.material = self.model.p.hasMaterial # Variable de Unreal
        self.actions = ["Moverse", "Cargar", "Regresar"]

    def see(self):
        self.thisTruck.posX = self.model.p.truckPosX # (float) Variable de Unreal
        self.thisTruck.posY = self.model.p.truckPosY # (float) Variable de Unreal
        self.thisTruck.material = self.model.p.hasMaterial # (bool) Variable de Unreal
        self.actions = ["Moverse", "Cargar", "Regresar"]
        #self.Zona = [Cliente() for c in self.model.clientes]

    def dist(self, posicionMaterialX, posicionMaterialY):

            return math.sqrt((self.thisTruck.posX-posicionMaterialX)**2 + (self.thisTruck.posY-posicionMaterialY)**2)

    # def teoria(self, action):
    #     if(self.dist(posicionMaterialX, posicionMaterialY) >= 10 and self.thisTruck.material == False and action == "Moverse"):
    #         return True
    #     if(self.dist(posicionMaterialX, posicionMaterialY) <= 10 and self.thisTruck.material == False and action == "Cargar"):
    #         return True
    #     if(self.thisTruck.material == True and action == "Regresar"):
    #         return True

    #     else:
    #         return False

    def teoria(self, action):
        #print(self.thisTruck.posX, self.thisTruck.posY)
        #print(self.dist(LOAD_POS.x, LOAD_POS.y))

        if(self.dist(LOAD_POS.x, LOAD_POS.y) > 300 and self.thisTruck.material == False and action == "Moverse"):
            return True
        if(self.dist(LOAD_POS.x, LOAD_POS.y) <= 300 and self.thisTruck.material == False and action == "Cargar"):
            return True
        if(self.thisTruck.material == True and action == "Regresar"):
            return True

        else:
            return False

    def ejecutar(self):
        select = ""
        for accion in self.actions:
            if self.teoria(accion):
                select = accion

                break
        #print(select)

        if select != "":
            global speed
            if select == "Moverse":
                 # Se mueve hacia los materiales y va un poco más lento
                speed = 1000
                return
                # self.model.grid.move_by(self, (1,1))
            if select == "Cargar":
                #print("Cargando material...")
                speed = 0  # No se mueve y en Unreal debe haber un condicional para que si la velocidad es 0 se espere 5 segundos y ya siga con el blueprint
                return
                # self.thisTruck.material = True
                # self.model.grid.move_by(self, (0,0))

            if select == "Regresar":
                speed = 700  # Se mueve hacia la salida y va un poco más lento porque va cargado
                return
                # self.model.grid.move_by(self, (-1,-1))



    def step(self):
        self.see()
        self.ejecutar() # Tiene que regresar un valor de speed

class MaterialAgent(ap.Agent):
  def setup(self):
    self.agentID = 1

#para agente de camara y otros trucks
# Solo cuenta camiones y si estan vacios o llenos

class CamaraAgente(ap.Agent):

      def setup(self):
        self.agentID = 2
        self.thisCamera = Camera()
        self.thisCamera.rangeP1 = [0,0]
        self.thisCamera.rangeP2 = [5,5]
        self.thisCamera.rx1, self.thisCamera.ry1 = self.thisCamera.rangeP1
        self.thisCamera.rx2, self.thisCamera.ry2 = self.thisCamera.rangeP2
        self.finishedLoading = False
        self.alreadyDetected = False
        self.thisCamera.detection = False
        self.detectionCount = 0
        self.decisions = ["Good Truck", "Bad Truck"]

      def see(self):
        # Vemos si el camion esta lleno y su posicion en la simulacion
        self.thisCamera.isTruckFilled = self.model.Truck.thisTruck.material[0]
        self.thisCamera.detectionX = self.model.Truck.thisTruck.posX[0] # si hubiera mas trucks sería como Truck[1].thisTruck.posX[0]
        self.thisCamera.detectionY = self.model.Truck.thisTruck.posY[0]

      def teoria(self):
        # Si entran al terreno ya se cuenta, esto solo sucede una vez por camion
        if self.thisCamera.detectionX == 0 and self.thisCamera.detectionY == 0 and self.alreadyDetected == False:
          self.detectionCount += 1
          self.alreadyDetected = True
          self.utility()

        # Si estan dentro del rango de vision de la camara los detecta
        if self.thisCamera.rx1 <= self.thisCamera.detectionX <= self.thisCamera.rx2 and self.thisCamera.ry1 <= self.thisCamera.detectionY <= self.thisCamera.ry2:
          self.thisCamera.detection = True
        else:
          self.thisCamera.detection = False

        # if self.thisCamera.isTruckFilled == True and self.mode.Truck.thisTruck.permitted:
          # elige decision de good truck o bad truck

      def ejecutar(self):
        # Si lo detecta y no tiene material
        if (self.thisCamera.detection == True and self.thisCamera.isTruckFilled == False):
          print("Camion detectado {sin material}")
        # Si lo detecta y si hay material
        elif (self.thisCamera.detection == True and self.thisCamera.isTruckFilled == True and self.finishedLoading == True):
          print("Camion detectado {con material}")
        else:
          print("Buscando deteccion...")


      # Mostrar los camiones detectados
      def utility(self):
        pass
        #print(f'Camiones detectados: {self.detectionCount}')

      def step(self):
          self.see()
          self.teoria()
          self.ejecutar()

class TruckModel(ap.Model):
    def setup(self):
        self.Truck = ap.AgentList(self,1,TruckAgent)
        #self.Camera = ap.AgentList(self,1,CamaraAgente)  # Agente camara
        #self.material = ap.AgentList(self,1,MaterialAgent)  # Creamos agente de material para introducirlo al grid


        # self.grid = ap.Grid(self, shape=(10000,10000))
        self.space = ap.Space(self, shape=(10000,10000))

        # Agregue al grid la zona donde se agarran los materiales y donde estaria la camara
        self.space.add_agents(self.Truck, [(self.p.truckPosX,self.p.truckPosY)])
        #self.grid.add_agents(self.material, [(5, 5)])
        #self.grid.add_agents(self.Camera, [(2, 12)])
        pass

    def step(self):
        self.Truck.step()
        #self.Camera.step()
        pass

    def update(self):
        # if self.Truck.thisTruck.posX[0] == 5 and self.Truck.thisTruck.posY[0] == 5 and self.Camera.finishedLoading[0] == False:
        #   print("Recogiendo material..")
        #   self.Camera.finishedLoading = True
        pass

    def end(self):
        #self.Camera.utility()
        self.space.remove_agents(self.Truck)
        #self.grid.remove_agents(self.material)

def main(truckPosX, truckPosY, hasMaterial):
    # onto = get_ontology("file:///content/ontologia_prueba.owl")
    # with onto:
    #   class Entidad(Thing):
    #         pass

    #   class Materiales(Entidad):
    #         pass

    #   class Truck(Entidad):
    #         pass

    #   class GoodTruck(Truck):
    #         pass

    #   class BadTruck(Truck):
    #         pass

    #   class Camera(Entidad):
    #         pass

    #   class PosX(DataProperty,FunctionalProperty):
    #         domain = [Entidad]
    #         range = [int]
    #   class PosY(DataProperty, FunctionalProperty):
    #         domain = [Entidad]
    #         range = [int]
    #   class Material(ObjectProperty, FunctionalProperty):
    #         domain = [Truck]
    #         range = [Materiales]

    parameters = {
        "steps" : 1,
        "truckPosX": truckPosX,
        "truckPosY": truckPosY,
        "hasMaterial": hasMaterial
    }





    #speed = 0
    model = TruckModel(parameters)
    model.run()
    #print(speed)
    return speed

# agenteCamion = TruckAgent()
# agenteCamion.step()

#print(speed)
#main(300, 300, False) # x, y y material
#print(speed)